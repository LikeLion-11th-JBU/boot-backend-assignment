## Spring Cloud
* 웹 개발 => 산출물 제공을 위한 자원(컴퓨터)
* => 원격에 있는 컴퓨터에서 특정 자원을 전달해줘서 브라우저라는 프로그램에서 확인을 한다.

* 서비스 제공을 위해 필요로 하는 자원을
* 사용자가 원할 때 즉시 제공을 할 수 있도록

* Spring Cloud
* 분산 시스템 개발의 지원
* Spring Cloud 프로젝트의 주요 목적은, 
이런 분산 시스템을 만드는데 도움이 되는 기술들을 제공하는데 목적이 있습니다. 
또한 다양한 클라우드 서비스 제공자들의 서비스를 편하게 사용할 수 있도록 하는 프로젝트들 또한 많이 포함되어 있음


* Service Discovery
* 한 서비스에서 다른 서비스로 요청을 보내야 하는 상황에서,
 저희는 단순하게 주소(URL)를 입력하여 위치를 지정하곤 했습니다. 하지만 상황에 따라 서비스의 위치가 변경되거나, 
 동일한 서비스를 제공하는 서비스가 여럿이거나, 어떤 서비스가 접속 불가능한 상태가 되게 될 경우 문제가 발생할 수 있습니다. 그래서 이런 서비스들의 상태를 관리하는 주체를 두고, 
 동적으로 변동되는 서비스의 위치와 상태를 파악할 수 있도록 하는 것이 Service Discovery 패턴

* Cloud computing
* 많은 컴퓨터들을 하나의 Cloud로 만드는
* 이 Cloud 어딘가에 어플리케이션이 생성되는 경우가 많고
* 이것의 위치를 정확히 명시하지 않음
* 정확히 어디에 어떤 어플리케이션이 실행되는지 알 수 없음

* 1. 클라이언트 사이드 서비스 디스커버리 : 클라이언트가 service registry에 요청을 보내면
그거에 따라 어떤 서비스로 요청을 보낼지 판단하는 방식

* 2. 서버 사이드 서비스 디스커버리 : 클라이언트와 서비스 사이에 load balancer가 존재하게 만들고 클라이언트가 load balancer가 service registry에
실제로 요청을 보내고자 하는 서비스의 위치를 파악한 수 그 해당 요청에 따라 서비스를 분산시켜 주는 역할을 하는 형태

* Cloud Config
* 설정 파일을 외부, 중앙에서 관리

## Microservice Architecture (MSA)

```
새로운 기능

- 로그인 기능 추가
- 위치 기반 조회
- 리뷰 게시글 작성
```
* 전통적인 개발은 하나의 큰 서비스를 만드는 방향으로 진행 모놀리스(Monolithic) 아키텍처

```
장점
1. 오롯이 개발에 집중 - 난이도 하락
2. 하나만 개발 - 테스트 편리
3. 산출물이 한가지 - 배포 편리
```
```
단점
기술 발전 속도가 빨라질수록 도드라짐
1. 어플리케이션의 구성요소가 서로에게 영향을 미치기 쉬움
2. 한 기능의 문제가 전체 어플리케이션을 위태롭게 만들 수 있음
3. 작은 기능 갱신을 위해 전체를 다시 배포해야 함
4. 서로 다른 기술 스택을 활용하기 힘듦.
```
* 빠른 요구사항 대응과 신기술 적용에 불리함.

* MSA => 작은 서비스들이 상호작용 할 수 있도록 만들어 놓는것.

```
MSA를 하지 말아야하는 이유 :
1. 서로 분리된 서비스이기 때문에 네트워크의 영향을 받음
2. 서로 다른 서비스의 기능을 요구할 때, 기능 구현 및 테스트가 어려움.
3. 자신이 필요로 하는 서비스의 상태를 확인하기 어려움.
4. 배포 과정이 더 복잡함.
```

```
MSA를 하는 이유
1. 상황에 맞는 기술 스택을 선택할 수 있음.
2. 기능이 개별적으로 발전, 개별 배포 용이
3. 개별 서비스의 복잡성이 적어짐.
4. 서비스의 규모에 따라 MSA가 필요 없을 수 도 있다.
```


