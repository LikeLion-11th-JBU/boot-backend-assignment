## Auth 와 HttpS
# Auth는 일반적으로 로그인하는 과정에 일어나는 일들을 함축하고 있는 단어.

* login : 한 개인이 자기 자신을 증명함으로서 특정 컴퓨터 시스템에 접근하는 행위

* Auth(Authorization & Authentication)
    * 사용자가 자신이 누구인지를 증명하는 과정 - Authentication => 로그인, 소셜 로그인 등
    * 사용자의 기능 사용 권한을 검증하는 과정 - Authorization => 권한 관리, 작성, 차단 등
    * HTTP를 사용하면 패킷을 볼 수 있음. 이를 통해 로그인 시 필요한 비밀번호를 볼 수도 있음

* 브라우저에서 정보는 쿠키로 저장
* 이걸 서버(-DB)에 로그인 요청을하면
* 그게 옳은 정보라면 `DB조회`를 통해 사용자 정보를 받아와서 `sessionid`를 키 `유저의 정보`를 밸류로 저장
* 사용자 브라우저에서 `sessionid`를 반환
* 다음단계로 요처을 보낼때마다(모든 HTTP 요청)에다가 `sessionid`를 포함 시킴
* 서버에서 `sessionid`에 값을 확인하고 그 소속된 유저정보를 파악함으로써 가져옴.

* 쿠키는 기본적으로 domain을 기반으로 저장이 됨.
* 다른 domain에서 쿠키를 볼 수 없음 예를들어 네이버에 저장된 쿠키는 다른 도메인에서 알 수 없음.

* HTTPS의 기반기술은 TLS이다.
    * TLS : 컴퓨터 네트워크 상에 정보를 안전하게 공유하기 위한 암호화 규칙 흔히 말하는 HTTPS는 HTTP에 TLS가 적용된 형태이다.

* 암호화 : 특정 규칙(알고리즘)을 가지고 `평범한 데이터(평문)`를 제3자가 확인 할 수 없도록 `정보를 숨기는 과정(암호문)`
    * 대칭키 암호화 : 같은 키를 사용하여 암호화 -> 빠르고 자원 소모가 적음 , 양쪽이 동일한 키를 가지고 있어야함 (대칭키)
    * 비대칭키 암호화(공개키 암호화) : 서로 다른 키를 사용해서 암호화 - 개인 키를 공개하지 않아 보안이 뛰어남, 하드웨어 자원 소모가 큼, 암호화 복호화에 시간이 오래거림.

* 비대칭키는 공개키와 개인키 둘다 있어야 제대로 작동가능함.

* TLS는 위의 둘다 사용함!
    * 브라우저에서 요청을보냄, 사용가능한 암호화 방식(대칭키 암호화 혹은 비대칭키의 암호화 방식)
    * 그럼 서버에서 선택한 암호화 방식 및 인증서를 보냄
    * 브라우저에 서버의 공개키가 있음. 그럼 브라우저에서 임의의 대칭키를 만듬. 이때 서버에는 개인키가 존재함.
    * 암호화된 대칭키를 서버에 전송해서 서버에 개인키를 이용해 대칭키를 확인함.
    * 공유된 대칭키를 이용해서 응답을 암호화해서 브라우저에 전송하면
    * 만들어진 대칭키로 암호문을 평문으로 만들어주고
    * 실제로 서비스를 제공받기위한 요청을 대칭키로 암호화해서 전달.

* TLS가 고안된 이유 : 공개키 암호화의 보안, 대칭키 암호화의 속도를 동시에 만족하기위해 만들어짐.
* TLS가 적용되지 않은 서비스는 개인정보가 얼마든지 유출될 수 있다.

-----
## Login 기본

* 	implementation 'org.springframework.boot:spring-boot-starter-security'
    * 이 dependency만 추가해줘도 로그인 창이 자동적으로 생김

* @EnableWebSecurity 를 추가하면 Spring Security를 조작할 준비가 되었다.

* `anyRequest()`가 선언되고 난 뒤에는 모든 요청에 대해서 처리하기 위한 존재이므로
* 뒤에는 특정 url에 대한 요청을 처리해야함. 
* `.authenticated()` // 로그인 한 사용자가 접근 하는 곳
* `.permitAll()` // 로그인을 했든 안했든 모든 사용자.
* `.antMatchers()` // 특정 url에 대해서 권한 설정
* `.antMatchers("/home/**")`// 작성해놓은 url에 접속 가능. *은 하나의 path를 의미함. **은 여러개 층에 나눈 path 전부다.
* `.anonymous()` // 로그인 하지 않은 사용자 접근가능
* `.and()` // authorizeRequest() 함수가 끝나고 다시 HttpSecurity 를 받아왔다는 것을 알 수 있음.
* `.formLogin()` // 로그인 페이지로 감. => 403대신 403이 나오면 login page로 리다이렉트를 해라 라는 내용까지 첨부가 됨.
-----
## login 커스텀
* isEnabled()랑 isAccountNonExpired() 관계만 파악
* NonExpired()는 계정이 발급 됐을 때 만료기한을 두고 발급됐을 때 사용을 하는 것을 권장
* 즉 일시적인 계정을 만들어야 할때, ex) 외부 인력이 들어와서 한동안 잠깐 프로젝트를 만들때
* 사용자가 기한에 따라 수동적임

* enabled는 보통 수동으로 휴면/계정사용 불가 사용자가 능동적으로 명시

* JWT(JSON Web Token) : 공개키 암호화를 이용하여 사용자 권한을 안전하게 주고 받는 용도
* 3개 부분으로 구성
* header : JWT를 만들기 위해 사용한 알고리즘에 대한 정보
* payload : claim 이라고 부르는 사용자 정보를 담는 부분
* signature : JWT가 유효한지 검증하기 위한 signature
* 전달하고 싶은 데이터를 비밀키로 전달함 이게 토큰이 됨.
* 공개키로 복호화를 함
* 비밀키를 이용해 암호화 : 만들 수 있는 대상이 한정적
* 공개키를 이용해 복호화 : 해석할 수 있는 대상은 제한 없음.

-----
## OAuth2와 JWT (Open Authorization 2 / Json Web Token)

* 소셜 로그인 이전에 서로 연관된, 그러나 독립된 서비스 (네이버 카페, 블로그, 쇼핑 등)
* Single Sign on : 로그인 한번에 자신의 정보를 공유하는 그럼으로 위와같은 네이버 카페, 블로그 등을 한번에 사용 할 수 있는.

* 작동 원리 => notion 확인.

* social login 과 single sign on 많은 부분 비슷
* 둘다 한번 로그인 해서 여러가지를 사용한다.
* single sign on : 하나의 큰 기업에서 여러개의 서비스에 대해 동일한 유저정보를 유지하고 동일한 로그인 인터페이스를 유지하기 위해 사용.
* 즉 하나의 기업에서 쓰는 (연관성이 있는) 방식

* social login : 네이버가 아니라 다른 회사들이 네이버에 계정정보를 사용하고자 하는 것.
* 즉 사용자가 네이버에 와서 로그인을 해줘야함.
* 연관성이 없는.



