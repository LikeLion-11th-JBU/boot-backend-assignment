interface 를 잘 활용하면 서로 다른 구현체가 같은 목적을 위해 동작하도록 만들 수 있다. 사용하고자 하는 객체의 실제 자료형과 무관하게 동작하게 만들 수 있다.
ArrayList의 실제 구현체를 살펴보면 ArrayListsms AbstactList를 확장하면서 List 구현체로서도 작동을 하고, 그 외에 RandomAccess, Cloneable같은 다른 인터페이스들도 구현하고 있다. 특히 구현체를 직접적으로 사용하는것 말고도 인터페이스를 직접 사용하는 것 들을 볼 수 있다.
함수의 인자와 반환값은 interface를 활용하자. -> ArrayList로서 새로운 List를 사용한다고 해도 사용되는 멤버변수의 형은 추상 인터페이스인 List를 사용한다. 
Ioc(inversion of Control) - 제어 역전, 일반적으로 개발자와 프레임워크가 있다. Spring이 등장하기 이전에 개발이라는 행위는 라이브러리를 사용한다. java에서는 json 라이브러리 패키지를 사용한다. 정의되어 있는 라이브러리의 코드를 가져다가 개발자가 사용하는 형태로 만들어지던게 Spring 이전의 전통적인 개발이다. Spring이 등장한 후로는 프레임워크가 자신이 해야하는 역할을 정확히 가지고 있다면, 개발자의 코드를 프레임워크가 가져다가 사용하게 된다. Spring 프레임워크는 어플리케이션 프레임워크이다. 대표적으로 웹 어플리케이션으로 사용된다. 웹 어플리케이션이 가질 수 있는 기능으로는 요청을 받고, 그 요청을 다시 보내는 것이다. 통신을 하는 부분들을 거의 항상 동일하게 작성이 된다. 반대로 그 통신을 받았을 때 신호(데이터)에 대한 비지니스 로직은 매번 바뀐다. 그래서 개발자가 항상 통신을 받는 부분을 개발하지 않고, 그 신호를 받고 데이터를 사용 했을 때, 어떠한 액션이 일어나야되는지만 개발하게 된다. 이 다음은 프레임워크가 알아서 잘 배치를 해준다. 즉, 제어역전은 개발자의 코드를 프레임워크가 사용을 하도록 제어가 역전되었다는 의미이다.

Spring에서 IoC를 담당하는 부분을 IoC Container라고 부른다. IoC Container는 개발자가 작성한 코드와 설정 정보를 합쳐서 프레임워크를 기반으로 만든 어플리케이션이 작동을 할 때 위 두가지(작성한 코드와 설정 정보)를 합쳐서 만들어져야되는 객체들을 직접만들어준다. -> new가 최소화 되어 있다. 즉, 개발자가 작성한 코드와 설정 정보를 합쳐서 완전한 Web Service를 만드는 프레임워크가 바로 Spring 프레임 워크이다. 개발자가 작성한 코드와 설정을 합친것을 Spring에서는 Beans이라는 단위로 부른다. 즉 Beans은 Spring IoC Container가 관리를 하는 객체이다. 
Spring 어플리케이션을 실행하게 된다면 Spring 프레임워크에서 요구하는 기준으로 만들어진 여러가지 객체들이 Beans이라는 모습으로 IoC Container에 배치가된다. 그리고 개발자가 비지니스 로직에 대한 코드를 작성을 하면서 다른 객체를 사용해야할 시점에서 IoC Container에서 이미 만들어져 있던 Beans 객체를 전달해준다. 이렇게 된다면 개발자가 new로 선언되어 있던 객체들을 정리한다던지, 어느 시점에 만들어진 객체를 어디에서 관리되고 있는지에 대해 신경을 덜 쓸 수 있다. 이런 식으로 이미 존재하는 Bean을 필요한 시점에 다시 주입을 시켜서 사용할 수 있게 해주는 부분을 dependency 인젝션(DI-의존성 주입)이라고 부른다.
userdetailsService라는 인터페이스는 사용자의 상세정보를 어떤식으로 검색하고 찾아내는지에 대한 인터페이스이다. Spring의 IoC의 기능은 인터페이스 기반으로 작동을 한다. 즉, 사용자 또는 Spring 프레임워크에 정의되어 있는 인터페이스들을 그 인터페이스에 맞게 작동을 하는 구현체들을 받아서 dependency 인젝션을 진행하게 된다.

Spring은 실행을 위해서 Tomcat같은 제2 웹 어플리케이션 서버 프로그램이 필요하다. Spring boot는 Tomcat 같은 서버 프로그램이 내장되어, Jar의 형태로 실행이 가능하다.