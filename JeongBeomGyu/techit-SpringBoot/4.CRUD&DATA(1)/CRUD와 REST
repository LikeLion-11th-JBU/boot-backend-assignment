CRUD와 REST의 관계
CRUD를 어떻게 RESTFUL하게 만드는지
RESTful이란 - 서버의 형태에 따라서 클라이언트의 형태가 고정되어 있을 경우 -> 즉 어느 한쪽의 변화가 상대방에게 큰 영향을 미치게 될 때(결합성이 높을 때) -> 좋은 구조로 만들어 있지 않다. 즉 REST는 클라이언트와 서버간의 결합성을 줄이기 위한 가이드이다. 가이드라인이 RESTful한 API를 만들기위한 가이드라인이다. 즉, 어떤 기술을 쓴다, 어떠한 형식으로 한다가 아니라 클라이언트가 사용할 API를 문제없이 누가 사용해도 가능하게 끔 만드는 것이 REST API를 만드는 과정이다.
6가지 제약사항을 잘 지킬 떄 RESTful한 API이다.
1. client server Architecture(클라이언트, 서버 모델)를 잘 따른다. (클라이언트와 서버간이 얼마나 잘 분리가 되어있는지, 서로의 역할을 얼마나 잘 분담을 하는지에 대한것. 서로의 변화가 서로에게 영향을 주지 않는 형태가 되어야 한다.-> 즉, 서버에서 자원을 관리를 하고, 자원에 대한 표현은 클라이언트에서만 신경을 쓴다. 그러면 클라이언트가 변화하더라도 서버가 변할 필요가 없다. 예를 들어 서버가 Spring Boot 2.5버전으로 업데이트 되어도 클라이언트에 영향이 가지않는다는 뜻이다. -> RequestMapping을 변경시키지 않는다.)
2. statelessness (상태라는 것을 가지지 않는다.즉, API자체가 상태를 저장해서 그것을 가지고 무언가를 만들어야되는 과정이 있으면 RESTful하지 않다. 서버를 사용하는 대상이 있는데, 서버가 요청을 받을 때마다 그 사용자가 누구였는지를 매번 다시 확인을 한다. 즉, 서버안에 사용자 정보를 저장하지 않는다. 모든 요청은 서로서로 독립적이면서, 요청을 보낸 당사자가 자신이 누구인지에 대한 책임을 지고 있는다. 원하는 기능을 위한 상태는 client가 가지고 있어야 한다.즉, 로그인 된 상태에서 API와 로그인 되지 않은 상태에서 API는 똑같은 엔드포인트를 가지고 있는다. API가 요청이 들어왔을 때, 어떤 사용자인지 증명을 하는 것은 그 API의 사용자 측에서 증명을 해야한다.)
3. Cacheability (재사용 가능한지에 대한 표현. 현재에 인터넷을 사용하고 있는 수많은 클라이언트들은 cach 기능을 가지고 있다. 즉, 한번 받은 이미지에 대해서 또 다시 받을 필요가 없고, 이를 서버가 알려줘야한다. 즉, 캐시 가능성으로 자원의 캐싱이 가능한지의 여부를 항상 서버가 표기해줘야 한다.)
4. Layered System (실제 서버까지 도달하는 과정을 클라이언트가 알 필요가 없다는 뜻이다. 클라이언트가 있고 서버가 있을 때, 일반적으로 요청을 처리하는 서버가 하나가 아닐 수도 있다. 즉, 서버 증축이 일어났을 때 서버와 클라이언트 사이에 어떤 구조로 이루어져있는지, 클라이언트가 몰라도 된다. 계층적인 구조. 즉 하나의 데이터 베이스에 여러 서버가 존재할 수 있는데, 만약 클라이언트가 위쪽 서버에 접속해야할 때, 그 사실을 클라이언트가 몰라도 되면 좋은 서버이고, 클라이언트가 알아야한다면 좋지 않은 서버이다.)
5. Uniformed Interface (이것에 맞춰서 이번 강의의 RESTful한 CRUD를 만들것이다. 일관된 인터페이스. 자원을 나타내기 위해서 사용을 해야하는 인터페이스. 요청에서 어떠한 자원에 대한 요청을 보내야하는 것인지가 명백하게 들어나야된다. 그리고 서버에서 응답을 돌려줄 때 그 자원 자체가 아닌, 그 자원의 형태를 띈 데이터를 돌려주는 것-> JS는 json을 사용한다.)
6. Code on Demand (REST를 잘 지켰을 때 어플리케이션을 실행 중인 와중에도 그 내용물,기능이 변할 수 있다.) (옵션) (기능을 요청을 했을 때, 바로 코드가 돌아온다. 일시적인 기능의 확장, 사용 가능한 코드를 응답으로 보내 사용자의 기능을 일시적으로 확장시킬 수 있다.)

API를 RESTful하게 설계하는 방법 -> 서비스가 커지면 100% REST의 조건을 만족하기 어렵다.
path (컴퓨터 안의 위치경로) -> 인터넷 상의 컴퓨터를 나타내는 부분까지 도달을 했다면 컴퓨터 안의 경로는 자원의 위치를 나타내는데 사용을 할 것이다. 아까는 이 경로에다가 어떠한 기능을 할 것인지를 작성을 했다. (create, read, read-all, update,delete )-> 그렇게 되면 어디의 기능이 들어간다. 즉, 경로(path)를 통해 도달하고자 하는 자원을 지정, 방법(메소드)을 통해 자원에 실행할 기능을 지정. (URL이란 어떤 자원이 어디에있는지 나타내기 위해서 사용하는 문자열이다. 거기에다 Delete,Creat등의 기능을 추가하고 있었다. -> 별로 좋은 형태가 아니다.)
PostController에서 사용자가 볼 수 있는 화면을 제공하는 RequestMapping, GetMapping 등을 만들고, RestContoller에서 실제로 그 화면들에서 사용을 하기 위한 내용들을 API들을 만들어주는 형태로 만들 수 있다. 
어떠한 자원의 위치를 지정해줌으로서 그 위치에다가 어떠한 일을 할지를 방식(메소드)을 통해서 전달을 해주고, 그것에 따라서 더 명확한 형태(어떠한 형태로 진행되었는지 ResponseStatus를 통해서)를 알 수 있다. 어떠한 새로운 자원(PostDto)에 대해서그 자원이 가지고 있어야할 데이터( createPost(@RequestBody PostDto postDto))를 전달을 하고, 또한 데이터를 수정을 하기 위해서 어디에 있는 지원인지(PathVariable("id") int id)와 그 자원이 가져야할 데이터들(@RequestBody PostDto postDto)을 전달할다. 지울 때는 어디에 있는지만(PathVariable("id") int id) 알면 된다. 마지막으로 모든것을 조회하고 싶을 때는 특별한 정보없이 GetMapping을, 하나만 특정하게 조회하고 싶을 때는 id까지 전달한다(GetMapping("{id}"))
명백하게 어디에 있는지, 어떤것을 찾고 싶을 때는 경로를 사용하고, 특정한 자원에 조건을 줘서 하고 찾고 싶을 때는 쿼리(리퀘스트 파라미터)를 사용한다.