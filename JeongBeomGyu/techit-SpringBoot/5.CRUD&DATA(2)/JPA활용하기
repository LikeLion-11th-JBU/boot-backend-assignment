Entity 작성하기
JPA HIBERNATE를 진행을 하면 HIBERNATE가 직접 schema를 조작해서 table을 만들고 그 안에 데이터를 넣고, 받고하는 부분을 직접 만들어서 구상을 해줘야한다.   
resource의 application.yml에는 
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://127.0.0.1:3306/demo_jpa_schema
    username: demo_jpa
    password: acoh3657!
  jpa:
    hibernate:
      ddl-auto: create
      show-sql: false
      properties:
        hibernate:
          dialect: org.hibernate.dialect.MySQL8Dialect
을 쓰는데 jpa는 어노테이션들의 라이브러리인데 여기서 hibernate는 실제로 이 라이브러리를 사용을 해서 table을 만들고 data를 다루는 프레임워크이다.
ddl-auto라는 부분은 table을 생성을 하고 제거를 하는 과정을 자동으로 해주는 것에 대한 옵션이다. 상용환경에서는 create로 사용하지 않는다. 높게 써봐야 Update이고, 일반적인 상황에서는 none을 사용한다. 
show-sql은 jpa가 작동을 하면서 실제로 실행을 하게되는 SQL문들이 있는데, 그것을 보여줄지 말지에 대한 설정이다.
dialect는 MySQL을 사용을 하니까 참고를 하라고 hibernate에 알려주는 역할을 한다.
DB별로 문법이 조금씩 다르다. Mybatis를 사용하면 직접 다 문법에 맞춰서 해야하지만, hibernate같은 경우는 대신 해주기 때문에, 어떤 DB를 사용할지 알려줘야하는 위치에 있다. 

우선 진행을 할 것은 PostEntity부터 할 것이다.
1. class 위에 @Entity를 해준다.
2. 필요로 하는 멤버변수들을 선언해준다.(JPA를 사용할 때는 class 기반의 object를 사용해줘야한다.)
    private Long id;    (즉 class 기반의 object란 long, int, String, char같은 것을 의미한다.)
    private String title;
    private String content;
    private String writer;
3. 멤버변수들 위에다가 @Id를 써준다. -> 이렇게 되면 Jpa에다가 Id가 table의 PrimaryKey 역할을 하는 변수인것을 알려주는 것이다.
    또한 @Id 밑에 @GeneratedValue(strategy = GenerationType.IDENTITY)를 작성해준다. -> 이것은 설정인데 table을 생성하면서 AutoGenerated, unique, PrimaryKey를 할 때 Id 생성하는 규칙을 설정해주기 위한 어노테이션이다. 
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String title;
    private String content;
    private String writer;
    를 한다음에 실행을하고 MySQL에서 확인해보면 table에 Post_Entity가 생성되고 id, title, content, writer이 들어가 있는 것을 확인할 수 있다. 즉, Jpa hibernate 같은 경우는 자신이 원하는 객체에다가 특정한 설정을 줌으로서, 그 테이블의 형태로 작성이된다. 또한 다양한 어노테이션을 사용해서 더 상세한 내용을 작성할 수 있다. 
4. 빈생성자와 Getter와 Setter, toString을 만들어준다.

그 다음은 BoardEntity를 작성한다.
1. class 위에다가 @Entity 어노테이션을 작성한다.
2. Board에는 멤버변수가 id와 name 밖에 없다.
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;
    private String name;
3. 빈생성자와 생성자, Getter와 Setter, toString을 만들어준다.

Post와 Board는 연관관계가 있다. PostEntity는 Board에 속해있다. Board는 여러개의 Post를 들고 있는 관계이다. 이것을 설정해 주기 위해서 
1. PostEntity에 어떤 것과 관계가 있는지 Entity로 표현을 해준다.
    private BoardEntity boardEntity; -> 즉 PostEntity는 BoardEntity를 가지고 있다. 근데 Post(게시글)는 Board(게시판)에 포함이 되어 있는 관계이다. 또한 게시판은 여러개의 게시글을 가지고 있을 수 있다.
2.  이러한 관계를 표시하기 위해서 어노테이션을 붙여준다.
    @ManyToOne()  -> Post가 여러개니까 Board는 한개이다라는 어노테이션을 붙여준다.-> 다대일 관계 -> 그래서 Jpa를 해도 ERD를 그려주는 것은 좋다.
    private BoardEntity boardEntity;
3. @ManyToOne()의 ()를 통해서 어떤 Entity를 상대로 관계를 맺는 것인지 상세한 정보를 준다.
    @ManyToOne(targetEntity = BoardEntity.class   -> BoardEntity를 상대로 관계를 맺는다. 
                fetch = FetchType.LAZY)  -> fetch에서 FetchType을 LAZY로 한다.

PostEntity에 BoardEntity가 추가가 되었고, 그것을 적용하기 위해서 Jpa HIBERNATE가 돌았는데, 그러면 
    @ManyToOne(targetEntity = BoardEntity.class
                fetch = FetchType.LAZY)
    private BoardEntity boardEntity; 
이것이 ForeignKey가 존재해서 ,BoardEntity에 있는 PrimaryKey를 가르키게된다. 근데 ManyToOne은 막 만들어져서 ForeignKey가 존재하지 않기때문에 Drop이 발생하는 것이다. 

Mysql을 새로 고침하면 board_entity가 추가된것을 볼 수 있다. 또한 Post_Entity에 board_entity가 추가된 것도 볼 수 있다. 또한 ForeignKey가 추가된 것을 볼 수 있다. 이것은 자동으로 생성이된 ForeignKey이다. 

BoardEntity에서 PostEntity를 조회를 한다. 하나의 board가 여러개의 Post를 들고 있다
1. 일대다 관계이기 때문에 @OneToMany 어노테이션을 사용하고 타겟을 PostEntity로 정한다. 또한 여러개의 Post값을 List 배열로 새로 정의한다.
@OneToMany(
            targetEntity = PostEntity.class,
            fetch = FetchType.LAZY,           -> FetchType은 연관관계에 있는 Entity를 불러올 때 어떤식으로 불러올지에 대한 방식을 정의해준다.
            mappedBy = "boardEntity"            -> mappedBy라는 것을 추가해주는데 mappedBy는 PostEntity에 있는 ManyToOne과                BoardEntity에 있는 OneToMany가 같은 관계라는 것을 나타낸다. 그렇기 때문에 mappedBy의 BoardEntity는 PostEntity의 ManyToOne관계에 정의된 private BoardEntity boardEntity의 boardEntity라는 변수의 이름과 동일하게 작성을 해주면 된다. 
    )
    private List<PostEntity> postEntityList = new ArrayList<>();
2. 생성자, Getter, Setter, toString을 새롭게 갱신해준다. (다시 만든다. -> PostEntityList가 추가되었기 때문이다.) 
3. PostEntity에 빈생성자가 아닌 생성자를 만들어준다.

여기까지가 table이 생성되는 것

지금부터 이것들을 사용하는 것 -> Repository 인터페이스를 사용한다.

BoardRepository 인터페이스를 확인한다.
1. Jpa에서 extends를 통해 BoardRepository를 CrudRepository로 확장한다. -> CRUD 작업을 하기위한 레포지토리를 위한 인터페이스다. 이때 CrudRepository는 2개의 GeneratedType을 요구하고 있다. <T, ID> 에서 T는 table의 t이고 id는 id 값이다. 즉, t에는 이 Repository가 어떤 Entity를 위한 것이냐가 들어가고, 뒤에 들어가는 것은 id가 어떤 타입으로 작성이 되는지를 써주면 된다.
    public interface BoardRepository extends CrudRepository<BoardEntity, Long> {
    }
이렇게 쓰면 BoardEntity에 대해서 BoardRepository를 사용할 수 있다.
이러면 BoardRepository에 대한것은 끝이 났다.
test를 위해서 TestComponent를 만든다.
BoardEntity newBoardEntity = boardRepository.save(boardEntity); 
-> PostEntity와 BoardEntity가 다 따로따로 작성이 되어 있는 코드이지만 둘은 서로 DB와 연관이 되어있다. 즉, 실제로 존재하는 데이터를 표현을 하는 객체들이기 때문에 코드 상에서도 항상 사용을 할때 save 이후에 변경된 사항들 또는 내용들(boardEntity)을 보기 위해서 save의 결과물을 돌려주는 BoardEntity가 실제로 생성된, 정상적으로 사용할 수 있는 Entity(newBoardEntity)라고 본다. 그렇기 때문에 이전에 선언해놨던 Entity는 사용을 하지말고 save를 하고 난 다음에 나오는 Entity(newBoardEntity), 엄밀히 말하면 boardEntity와 동일한 결과가 나오게끔만들어져있고 원래의 Entity 객체를 완전히 바꿔놓았을 수 있기 때문에 반환된 Entity(newBoardEntity)를 사용해야한다.

PostRepository 역시 BoardRepository와 유사하게 만든다.
1. Jpa에서 extends를 통해 PostRepository를 CrudRepository로 확장한다. -> CRUD 작업을 하기위한 레포지토리를 위한 인터페이스다. 이때 CrudRepository는 2개의 GeneratedType을 요구하고 있다. <T, ID> 에서 T는 table의 t이고 id는 id 값이다.
    public interface PostRepository extends CrudRepository<PostEntity, Long>
이렇게 쓰면 PostEntity에 대해서 PostRepository를 사용할 수 있다.

추가적인 기능 
1. PostRepository에 List<PostEntity> findAllByWriter(String writer) -> Post가 findAll이니까 결과도 List로 나타낸다.

2. PostEntity에서 조회(Find)를 하는 기준에 대해서 어떤식으로 작성을 해야 되는지에 대한 내용(insert, delete, update 경우에는 Entity 그 자체를 돌주면 되므로 사실상 find인데 기본적으로 findAllBy로 시작을 하게 되고 그 뒤에는 where문에다가 넣어 줄 부분을 어떤식으로 작성하는 것이다.)
  PostRepository에서 PostEntity findAllByWriterAndBoard()를 하게 되면 인자는 어떻게 주느냐 -> writer는 String으로 주면 되고, Board는 BoardEntity로 주면 된다. 또한 PostEntity에는 findAll 값이 들어가므로 List형태로 선언해준다.
    List<PostEntity> findAllByWriterAndBoard(String writer, BoardEntity boardEntity) -> where 문에서는 where writer = ? and board_entity_id = ?

3. List<PostEntity> findAllByWriterContaining(String writer); 로 나타낼 수 도 있다. 이렇게 되면 writer에 있는 그 자체를 사용하는 것 보다는, writer에 내용을 포함하는 내용을 기준으로 검색을 하게 된다.
Jpa는 CrudRepository만 하면 기본적인 CRUD Operation이 다 지정이 되었다. 그래서 jpa가 초반에 들어가기가 쉬울 것이다.
근데 SQL을 먼저 배웠다면 mybatis에서 인자만 전달해주면 결과가 다시 Dto의 형태(java object 형태)로 돌아온다.

BaseEntity는 만약에 모든 Entity들이 가져야될 속성에 대해서 정의를 하고 싶다.

1. BaseEntity class 위에다가 @MappedSuperclass 어노테이션을 붙여준다. 그리고 @EntityListeners(AuditingEntityListener.class) 어노테이션을 밑에 붙여준다.
2. class를 추상클래스 (abstract)로 만들어주고 class안에 @CreatedData어노테이션과 @Column(updatable = false)어노테이션을 넣어준다.  
3. 멤버변수 private Instant createdAt; -> java 시간에 있는 Instant라는 클래스를 사용해서 언제 생성되었느냐를 모든 table에 넣는다.
4. @LastModifiedDate 어노테이션과 @Column(updatable = true) 어노테이션을 클래스 안에 넣는다.
5. 그 밑에 멤버변수 private Instant updatedAt; -> 이것은 마지막 갱신시간을 나타낸다.
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public class BaseEntity {
    @CreatedDate
    @Column(updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(updatable = true)
    private Instant updatedAt;

6. getter와 setter를 만들어준다.
7. PostEntity 클래스에다가 extends로 BaseEntity를 넣어주면 된다. 
    public class PostEntity extends BaseEntity

8. BoardEntity 클래스에다가 extends로 BaseEntity를 넣어준다.
    public class BoardEntity extends BaseEntity
BaseEntity는 추상클래스임으로 자신이 할 수 있는것을 다 넘겨주고 있다. 또한 추상 함수(메소드)는 없기 때문에 추가적으로 구현을 해줘야할 부분은 없다.
9. Auditing이라는 것은 Spring Boot 기본 comfignation에 설정이 되어 있지 않으므로 허용을 해줘야한다.
JpaApplication 클래스에 @EnableJpaAuditing 어노테이션을 붙여준다.

그 다음 실행은 하면 mysql에서 board_entity와 Post_Entity 둘다 created_at(생성 시), updated_at(갱신 시)가 추가되어 있다는 것을 확인할 수 있다.

@Entity 어노테이션을 붙여준것은 JPa에서 어떻게 작동을 해야하는지 라는 것을 알려주는 것이다.
추가적으로 PostEntity 클래스 위에 @Table()이라는 어노테이션 @Table(name = 'post')을 붙이고 
@JoinColumn(name = "board_id")
    private BoardEntity boardEntity;
    을 붙이고 
BoardEntity에도 동일하게 클래스 위에 @Table(name = "board")라는 어노테이션을 붙여주고 
@Column(name = "board_name")
    private String name;
    을 붙인다.
그 다음 실행한 다음 mysql을 보면 이전에 만들었던 table이 남아있을 것이다. board와 post안에 board_name과 Post_name이 들어가 있는 것을 확인할 수 있다.


